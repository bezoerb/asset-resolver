'use strict';
const path = require('path');
const url = require('url');
const fs = require('fs-extra');
const request = require('request');
const mime = require('mime');
const Bluebird = require('bluebird');
const debug = require('debug')('asset-resolver');
const result = require('lodash/result');
const reduce = require('lodash/reduce');
const globby = require('globby');

const cache = {};

function isUrl(resource) {
	return /(^\/\/)|(:\/\/)/.test(resource);
}

function handle(filter) {
	return function (resource) {
		debug('handle request', resource.path);
		return Bluebird.resolve(resource)
			.then(filter)
			.then(result => {
				if (!result) {
					debug('FAILED');
					return Bluebird.reject(new Error(resource.path + ' rejected by filter'));
				}
				debug('Passed filter:', resource.path);
				return resource;
			});
	};
}

/**
 * Token generated by concatenating username and password with `:` character within a base64 encoded string.
 * @param  {String} user User identifier.
 * @param  {String} pass Password.
 * @returns {String} Base64 encoded authentication token.
 */
const token = (user, pass) => Buffer.from([user, pass].join(':')).toString('base64');

/**
 * Get external resource
 * @param {string} resource Ressource to be fetched
 * @param {object} opts Option hash
 * @returns {Promise} Promise
 */
function requestAsync(resource, opts = {}) {
	const settings = {
		followRedirect: true,
		encoding: null,
		rejectUnauthorized: false
	};

	if (opts.user && opts.pass) {
		settings.headers = {Authorization: 'Basic ' + token(opts.user, opts.pass)};
	}

	return new Bluebird((resolve, reject) => {
		// Handle protocol-relative urls
		resource = url.resolve('http://te.st', resource);
		request(resource, settings, (err, resp, body) => {
			let msg;
			if (err) {
				debug('Url failed:', err.message || err);
				return reject(err);
			}
			if (resp.statusCode !== 200) {
				msg = 'Wrong status code ' + resp.statusCode + ' for ' + resource;
				debug(msg);
				return reject(new Error(msg));
			}

			const mimeType = result(resp, 'headers.content-type') || mime.getType(resource);

			resolve({
				contents: body,
				path: resource,
				mime: mimeType
			});
		});
	});
}

/**
 * Get local resource
 * @param {string} resource Resource to be fetched
 * @returns {Promise} Promise
 */
function readAsync(resource) {
	return fs.readFile(resource).then(body => {
		const mimeType = mime.getType(resource);

		debug('Fetched:', resource);

		return Bluebird.resolve({
			contents: body,
			path: resource,
			mime: mimeType
		});
	});
}

function join(base, file) {
	if (isUrl(file)) {
		return file;
	}
	if (isUrl(base)) {
		if (!/\/$/.test(base)) {
			base += '/';
		}
		return url.resolve(base, file);
	}

	return path.join(base, file);
}

function glob(base) {
	return reduce(base, (res, val) => {
		if (isUrl(val)) {
			res.push(val);
			return res;
		}

		if (fs.existsSync(val) && fs.lstatSync(val).isDirectory()) {
			res.push(val);
			return res;
		}

		let files = [];
		try {
			files = globby.sync([val], {nodir: false, onlyDirectories: true});
		} catch (err) {
			console.error(err.message);
		}

		return res.concat(files);
	}, []);
}

function getResource(base, file, opts) {
	const resource = join(base, file);
	if (cache[resource]) {
		return cache[resource].then(handle(opts.filter));
	}

	if (isUrl(resource)) {
		cache[resource] = requestAsync(resource, opts);
	} else {
		cache[resource] = readAsync(resource, opts);
	}
	return cache[resource].then(handle(opts.filter));
}

module.exports.getResource = getResource;
module.exports.glob = glob;
