'use strict';

const fs = require('fs');
const path = require('path');
const url = require('url');
const {promisify} = require('util');
const got = require('got');
const normalize = require('normalize-path');
const mime = require('mime');
const debug = require('debug')('asset-resolver');
const globby = require('globby');

const readFile = promisify(fs.readFile);

function isUrl(resource) {
  return resource.startsWith('//') || resource.includes('://');
}

/**
 * Token generated by concatenating username and password with `:` character within a base64 encoded string.
 * @param  {String} user User identifier.
 * @param  {String} pass Password.
 * @returns {String} Base64 encoded authentication token.
 */
const token = (user, pass) =>
  Buffer.from([user, pass].join(':')).toString('base64');

/**
 * Get external resource
 * @param {string} resource Ressource to be fetched
 * @param {object} opts Option hash
 * @returns {Promise} Promise
 */
function requestAsync(resource, options = {}) {
  const settings = {
    followRedirect: true,
    // encoding: null,
    https: {rejectUnauthorized: false},
    retry: 0,
    responseType: 'buffer'
  };

  if (options.user && options.pass) {
    settings.headers = {
      Authorization: `Basic ${token(options.user, options.pass)}`
    };
  }

  return new Promise((resolve, reject) => {
    // Handle protocol-relative urls
    resource = url.resolve('http://te.st', resource); // eslint-disable-line node/no-deprecated-api
    got(resource, settings)
      .then((response) => {
        if (response.statusCode !== 200) {
          const message = `Wrong status code ${response.statusCode} for ${resource}`;
          debug(message);
          return reject(new Error(message));
        }

        const {headers = {}} = response;

        const mimeType = headers['content-type'] || mime.getType(resource);

        resolve({
          contents: response.body,
          path: resource,
          mime: mimeType
        });
      })
      .catch((error) => {
        debug('Url failed:', error.message || error);
        return reject(error);
      });
  });
}

/**
 * Get local resource
 * @param {string} resource Resource to be fetched
 * @returns {Promise} Promise
 */
function readAsync(resource) {
  return readFile(resource).then((body) => {
    const mimeType = mime.getType(resource);

    debug('Fetched:', resource);

    return {
      contents: body,
      path: path.resolve(resource),
      mime: mimeType
    };
  });
}

function join(base, file) {
  if (isUrl(file)) {
    return file;
  }

  if (isUrl(base)) {
    // eslint-disable-next-line node/no-deprecated-api
    return url.resolve(base.endsWith('/') ? base : `${base}/`, file);
  }

  return path.join(base, file);
}

function glob(base) {
  // eslint-disable-next-line unicorn/no-reduce
  return base.reduce((result, value) => {
    if (isUrl(value)) {
      result.push(value);
      return result;
    }

    if (fs.existsSync(value) && fs.lstatSync(value).isDirectory()) {
      result.push(value);
      return result;
    }

    let files = [];
    try {
      const pattern =
        value.endsWith('/') || value.endsWith('\\')
          ? value.slice(0, Math.max(0, value.length - 1))
          : value;
      files = globby.sync([normalize(pattern)], {
        nodir: false,
        onlyDirectories: true,
        cwd: process.cwd()
      });
    } catch (error) {
      console.error(error.message);
    }

    return [...result, ...files];
  }, []);
}

async function getResource(file, options) {
  const {base, filter = () => true, cwd: _cwd = process.cwd(), glob = {}} =
    options || {};

  const cwd = glob.cwd || _cwd;

  const searchBase = Array.isArray(base) ? base : [base].filter((r) => r);

  const patterns = searchBase.map((base) => join(base, file));

  const errors = [];
  // try files first
  const globPatterns = patterns
    .filter((pattern) => !isUrl(pattern))
    .map((dirPattern) =>
      // fix for https://github.com/mrmlnc/fast-glob/issues/266
      path.isAbsolute(dirPattern)
        ? normalize(path.relative(cwd, dirPattern))
        : normalize(dirPattern)
    );

  const filepaths = (await globby(globPatterns, {cwd, ...glob})) || [];

  if (filepaths) {
    for (const filepath of filepaths) {
      const resource = await readAsync(filepath);
      if (await filter(resource)) {
        return resource;
      }

      errors.push(new Error(`${filepath} rejected by filter`));
    }
  }

  if (filepaths.length === 0 && globPatterns.length > 0) {
    errors.push(new Error(`No such file or directory: ${globPatterns}`));
  }

  const urls = patterns.filter((resource) => isUrl(resource));
  for (const url of urls) {
    try {
      const resource = await requestAsync(url, options);
      if (await filter(resource)) {
        return resource;
      }

      errors.push(new Error(`${url} rejected by filter`));
    } catch (error) {
      errors.push(error);
    }
  }

  throw new Error(errors.map((error) => `${error.message}\n`));
}

module.exports.getResource = getResource;
module.exports.glob = glob;
